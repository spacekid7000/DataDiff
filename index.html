<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Audio Diffuser — Web Audio</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="container">
    <header>
        <h1>Audio Diffuser</h1>
        <p class="subtitle">Upload · Warp · Preview — WebAudio powered</p>
    </header>

    <main>
      <!-- LEFT COLUMN: CONTROLS -->
      <div class="main-col">
        <div class="card" id="controls-container">
          <div class="card-header">
            <h2>CONTROLS</h2>
          </div>
          <div class="card-content">

            <div class="control-group">
                <div class="upload-area-wrapper">
                    <label class="file-input-label" for="file">
                        <div class="file-label-title">Click to upload WAV / MP3</div>
                        <div id="fileName" class="file-name">No file selected</div>
                        <input id="file" type="file" accept="audio/*">
                    </label>
                </div>
            </div>

            <div class="control-group">
              <label for="alg">Algorithm</label>
              <select id="alg">
                <option>Spectral smudge</option>
                <option>Micro-granular shuffle</option>
                <option>Chaotic waveshaper</option>
                <option>Binaural phase mod</option>
                <option>Mirror clip</option>
                <option>Granular decay</option>
                <option>Pitch bend chaos</option>
                <option>Reverse reverb</option>
                <option>Evolving bit-crush</option>
                <option>Flutter tremolo</option>
              </select>
            </div>

            <div class="control-group">
              <label>Intensity <span id="intv">0.50</span></label>
              <div class="slider-wrapper">
                <span class="slider-label">0.0</span>
                <input id="int" type="range" min="0" max="1" step="0.01" value="0.5">
                <span class="slider-label">1.0</span>
              </div>
            </div>

            <div class="control-group">
              <label>Chaos (randomness) <span id="chaosv">0.50</span></label>
              <div class="slider-wrapper">
                <span class="slider-label">0.0</span>
                <input id="chaos" type="range" min="0" max="1" step="0.01" value="0.5">
                <span class="slider-label">1.0</span>
              </div>
            </div>
            
            <div class="control-group">
                <label class="checkbox-label">
                    <input id="undef" type="checkbox"> Undefuse mode (partial reverse)
                </label>
                <label class="checkbox-label">
                    <input id="loopToggle" type="checkbox"> Download as loop (crossfade)
                </label>
            </div>

            <div class="action-buttons">
              <button id="diffuse" class="btn btn-primary">Diffuse</button>
              <button id="previewBtn" class="btn">Preview</button>
              <button id="next" class="btn">Next</button>
              <button id="download" class="btn">Download</button>
            </div>
          </div>
        </div>
      </div>

      <!-- RIGHT COLUMN: PREVIEW & VISUALIZATION -->
      <div class="main-col">
        <div class="card">
            <div class="card-header">
                <h2>PREVIEW</h2>
            </div>
            <div class="card-content">
                <audio id="player" controls style="width:100%"></audio>
                <div style="display:flex; justify-content: space-between; font-size: 0.8em; color: var(--secondary-text-color); margin-top: 1rem;">
                    <div>Seed: <span id="seed">-</span></div>
                    <div>WebAudio</div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-header">
                <h2>ALGORITHM QUICK LIST</h2>
            </div>
            <div class="card-content">
                 <div class="flip-container">
                    <button id="flipBtn" title="Shuffle list">
                        <svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
                    </button>
                </div>
                <div class="alg-list" id="algList" style="height: 220px; overflow-y: auto; margin-top: 1rem;"></div>
            </div>
        </div>

        <div class="waveform-container card">
            <div class="waveform-header">
                <h3>Playback Visualization</h3>
            </div>
            <div class="canvas-wrapper">
                 <div class="playhead"></div>
                 <canvas id="wave"></canvas>
            </div>
        </div>
      </div>
    </main>
  </div>

<script>
/* ===== Audio Diffuser (new algorithm set implemented) ===== */
let audioCtx, originalBuffer, processedBuffer, currentSeed=Date.now(), lastAlg=null;
const fileInput = document.getElementById('file'), alg = document.getElementById('alg'),
      int = document.getElementById('int'), intv=document.getElementById('intv'),
      chaos=document.getElementById('chaos'), chaosv=document.getElementById('chaosv'),
      diffBtn=document.getElementById('diffuse'), previewBtn=document.getElementById('previewBtn'),
      nextBtn=document.getElementById('next'), downloadBtn=document.getElementById('download'),
      player=document.getElementById('player'), undef=document.getElementById('undef'),
      loopToggle=document.getElementById('loopToggle'), seedLabel=document.getElementById('seed'),
      fileNameLabel=document.getElementById('fileName'), algListEl=document.getElementById('algList'),
      flipBtn=document.getElementById('flipBtn');

const algList = ["Spectral smudge","Micro-granular shuffle","Chaotic waveshaper","Binaural phase mod","Mirror clip","Granular decay","Pitch bend chaos","Reverse reverb","Evolving bit-crush","Flutter tremolo"];

function prng(seed){
  let s = seed|0;
  return ()=>{ s = Math.imul(48271, s) % 2147483647; return (s & 0x7fffffff)/2147483647; };
}
function ensureCtx(){ if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); return audioCtx; }

/* populate algorithm list visually */
function refreshAlgList(){
  algListEl.innerHTML = '';
  algList.forEach((a,i)=>{
    const d = document.createElement('div');
    d.textContent = a;
    d.className = 'alg-item' + (alg.selectedIndex===i ? ' active' : '');
    // Simple styling for alg-item as it's not in the CSS
    d.style.padding = '8px';
    d.style.borderRadius = '4px';
    d.style.cursor = 'pointer';
    d.style.color = 'var(--secondary-text-color)';
    if (alg.selectedIndex === i) {
        d.style.background = 'rgba(0,123,255,0.1)';
        d.style.color = 'var(--primary-text-color)';
    }
    d.onclick = ()=>{ alg.selectedIndex = i; highlightAlg(); };
    algListEl.appendChild(d);
  });
}
function highlightAlg(){ 
    const items = document.querySelectorAll('.alg-item'); 
    items.forEach((it,i)=>{
        it.style.background = (alg.selectedIndex===i) ? 'rgba(0,123,255,0.1)' : 'transparent';
        it.style.color = (alg.selectedIndex===i) ? 'var(--primary-text-color)' : 'var(--secondary-text-color)';
    });
}
refreshAlgList();

/* file load */
fileInput.onchange = async e=>{
  const f = e.target.files[0]; if(!f) return;
  ensureCtx();
  const ab = await f.arrayBuffer();
  originalBuffer = await audioCtx.decodeAudioData(ab);
  processedBuffer = null;
  fileNameLabel.textContent = f.name;
  player.src = URL.createObjectURL(f);
  seedLabel.textContent = '-';
  drawWaveformFromBuffer(originalBuffer);
};

/* sliders */
int.oninput = ()=>{ intv.textContent = parseFloat(int.value).toFixed(2); if(player.src && processedBuffer) liveUpdate(); }
chaos.oninput = ()=>{ chaosv.textContent = parseFloat(chaos.value).toFixed(2); }

/* helpers */
function cloneBuffer(buf){
  const ctx = ensureCtx();
  const out = ctx.createBuffer(buf.numberOfChannels, buf.length, buf.sampleRate);
  for(let ch=0; ch<buf.numberOfChannels; ch++) out.getChannelData(ch).set(buf.getChannelData(ch));
  return out;
}

/* tiny convolution helper (small IR) */
function convolveSmall(data, ir){
  const out = new Float32Array(data.length);
  const L = data.length, M = ir.length;
  for(let i=0;i<L;i++){
    let s = 0;
    for(let j=0;j<M && j<=i;j++){
      s += data[i-j] * ir[j];
    }
    out[i] = s;
  }
  return out;
}

/* simple linear resample */
function resampleArray(src, rate){
  const L = src.length;
  const out = new Float32Array(L);
  let pos = 0;
  for(let i=0;i<L;i++){
    const ip = Math.floor(pos);
    const frac = pos - ip;
    const a = src[ip] || 0;
    const b = src[ip+1] || 0;
    out[i] = a*(1-frac) + b*frac;
    pos += rate;
    if(pos >= L) pos -= L;
  }
  return out;
}

/* applyAlgorithm - new implementations */
function applyAlgorithm(buf, algorithm, intensity, chaosVal, seed, undefuseMode){
  const ctx = ensureCtx();
  const out = cloneBuffer(buf);
  const rnd = prng(seed);
  const mix = intensity;
  const len = out.length;

  for(let ch=0; ch<out.numberOfChannels; ch++){
    const data = out.getChannelData(ch);
    const src = buf.getChannelData(ch);

    switch(algorithm){

      /* SPECTRAL SMUDGE
         - small randomized IR convolution applied in short windows
         - approximates gentle spectral smear (shimmer) without heavy FFT
      */
      case "Spectral smudge":{
        const windowSize = Math.max(256, Math.floor(1024 * (1 - chaosVal*0.75)));
        const irBaseLen = Math.max(32, Math.floor(64 + chaosVal*256));
        const ir = new Float32Array(irBaseLen);
        // create a gentle resonant-ish IR with random harmonic emphasis
        for(let i=0;i<irBaseLen;i++){
          const t = i/(irBaseLen-1);
          ir[i] = (0.5 - 0.5*Math.cos(Math.PI*t)) * Math.pow(1 - t, 2); // fade
          // add tiny random spectral bumps
          ir[i] *= 1 + (rnd()-0.5)*chaosVal*0.6;
        }
        // process in windows with crossfade
        const outbuf = new Float32Array(len);
        for(let pos=0; pos<len; pos+=windowSize){
          const block = Math.min(windowSize, len-pos);
          const blockData = src.subarray(pos, pos+block);
          const conv = convolveSmall(blockData, ir);
          for(let i=0;i<block;i++){
            const idx = pos+i;
            const dry = src[idx];
            const wet = conv[i] || 0;
            // crossfade edges
            const edge = Math.min(i, Math.min(block-1-i, 16))/16;
            const fade = 0.5 + 0.5*edge;
            outbuf[idx] += dry*(1 - mix*fade) + wet*(mix*fade);
          }
        }
        // write back
        for(let i=0;i<len;i++) data[i] = outbuf[i];
      } break;

      /* MICRO-GRANULAR SHUFFLE
         - small grains (5-60 ms) with random offset + overlap crossfade
      */
      case "Micro-granular shuffle":{
        const sr = buf.sampleRate;
        const minMs = 5 + chaosVal*0; // in ms
        const maxMs = 60 - chaosVal*30; // smaller if chaotic
        const minS = Math.max(4, Math.floor(minMs*sr/1000));
        const maxS = Math.max(minS+1, Math.floor(maxMs*sr/1000));
        const outg = new Float32Array(len);
        const overlap = Math.floor((minS+maxS)/4);
        for(let pos=0; pos<len; pos+=Math.floor((minS+maxS)/2)){
          const gsize = Math.floor(minS + rnd()*(maxS-minS));
          const srcOff = Math.max(0, Math.floor(pos + (rnd()*2-1) * chaosVal * gsize * 2));
          const winLen = Math.min(gsize, len-pos, len-srcOff);
          for(let i=0;i<winLen;i++){
            // hann window
            const env = 0.5 - 0.5*Math.cos(Math.PI*(i/winLen));
            outg[pos+i] += src[srcOff+i]*env;
          }
        }
        for(let i=0;i<len;i++) data[i] = data[i]*(1-mix) + outg[i]*mix;
        if(undefuseMode){
          for(let i=0;i<len;i++) data[i] = data[i]*(1-0.4*mix) + src[i]*0.4*mix;
        }
      } break;

      /* CHAOTIC WAVESHAPER
         - waveshape via tanh + small feedback delay for a richer harmonic palette
      */
      case "Chaotic waveshaper":{
        const drive = 1 + mix*8;
        const delayLen = Math.min(len, Math.floor(0.005 * buf.sampleRate)); // 5ms feedback
        const fbBuffer = new Float32Array(delayLen+1);
        let fbIdx = 0;
        for(let i=0;i<len;i++){
          let x = src[i];
          // feedback injection
          x += fbBuffer[fbIdx] * 0.15 * chaosVal * mix;
          // biased waveshaping
          let y = Math.tanh(x * drive) + 0.2 * Math.sin(x * 15 * (1+chaosVal));
          // write feedback
          fbBuffer[fbIdx] = y;
          fbIdx = (fbIdx + 1) % fbBuffer.length;
          data[i] = data[i]*(1-mix) + y*mix;
        }
      } break;

      /* BINAURAL PHASE MOD
         - create stereo phase offset by delaying one channel slightly and modulating delay
      */
      case "Binaural phase mod":{
        // only meaningful for 2+ channels; if mono, simulate stereo by splitting
        const sr = buf.sampleRate;
        const maxDelayMs = 8 + chaosVal*12; // up to ~20ms variation
        const base = Math.floor(((ch===0) ? 1 : 0) * (1 + (mix*maxDelayMs/1000)) * sr * 0.002); // small offset per channel
        const delaySamples = Math.floor((1 + mix*maxDelayMs*0.001*sr) * (0.5 + chaosVal*2));
        // implement simple fractional delay via linear interpolation with slow LFO
        const lfoRate = 0.1 + chaosVal*2.0; // Hz-ish (very slow changes)
        for(let i=0;i<len;i++){
          const lfo = 0.5 + 0.5*Math.sin(2*Math.PI*(i/ sr) * lfoRate + seed*0.0001);
          const d = Math.max(0, Math.floor((lfo * maxDelayMs/1000) * sr));
          const ip = i - d;
          const val = (ip>=0) ? src[ip] : 0;
          // slightly detune amplitude for stereo width
          const stereoBoost = (ch===0) ? (1 + mix*0.08) : (1 - mix*0.08);
          data[i] = data[i]*(1-mix) + val * mix * stereoBoost;
        }
        // if mono, allow undefuse to blend original
        if(undefuseMode){
          for(let i=0;i<len;i++) data[i] = data[i]*(1-0.5*mix) + src[i]*0.5*mix;
        }
      } break;

      /* MIRROR CLIP
         - fold samples above threshold and add small harmonic shimmer
      */
      case "Mirror clip":{
        const threshold = 0.12 + chaosVal*0.28; // fold threshold
        for(let i=0;i<len;i++){
          let s = src[i];
          if(Math.abs(s) > threshold){
            const over = Math.abs(s) - threshold;
            s = (s>0 ? 1 : -1) * (threshold - over); // mirror
            // add tiny harmonic via cubic
            s += 0.02 * Math.pow(src[i],3) * chaosVal;
          }
          data[i] = data[i]*(1-mix) + s*mix;
        }
      } break;

      /* GRANULAR DECAY (improved)
         - grains with random durations and per-grain randomized envelopes
      */
      case "Granular decay":{
        const sr = buf.sampleRate;
        const maxGrainMs = 120 * (1 - chaosVal*0.6); // up to ~120ms
        const minGrainMs = 15;
        const outg = new Float32Array(len);
        for(let pos=0; pos<len; pos+=Math.floor((minGrainMs*sr)/1000)){
          if(rnd() > 0.7 + (1-mix)*0.3) continue;
          const gMs = minGrainMs + rnd()*(maxGrainMs-minGrainMs);
          const gLen = Math.max(4, Math.floor(gMs*sr/1000));
          const srcOff = Math.max(0, Math.floor(pos + (rnd()*2-1)*chaosVal*gLen*2));
          const envType = Math.random() > 0.5 ? 'hann' : 'exp';
          for(let i=0;i<gLen && (pos+i)<len && (srcOff+i)<len;i++){
            let env;
            if(envType==='hann') env = 0.5 - 0.5*Math.cos(Math.PI*(i/gLen));
            else env = Math.pow(1 - (i/gLen), 2);
            outg[pos+i] += src[srcOff+i]*env;
          }
        }
        for(let i=0;i<len;i++) data[i] = data[i]*(1-mix) + outg[i]*mix;
        if(undefuseMode){
          for(let i=0;i<len;i++) data[i] = data[i]*(1-0.35*mix) + src[i]*0.35*mix;
        }
      } break;

      /* PITCH BEND CHAOS (keep + enhance)
         - random resampling with time-varying rate (kept from original but smoothed)
      */
      case "Pitch bend chaos":{
        const tmp = new Float32Array(len);
        let pos = 0;
        let rate = 1;
        for(let i=0;i<len;i++){
          // smoother random changes using lowpass on rate
          rate += (rnd()-0.5)*chaosVal*0.02*(1+mix*6);
          rate = Math.max(0.5, Math.min(2.5, rate));
          pos += rate;
          const ip = Math.floor(pos) % len;
          tmp[i] = src[Math.max(0,Math.min(len-1,ip))];
        }
        for(let i=0;i<len;i++) data[i] = data[i]*(1-mix) + tmp[i]*mix;
        if(undefuseMode){
          for(let i=0;i<len;i++) data[i] = data[i]*(1-0.5*mix) + src[i]*0.5*mix;
        }
      } break;

      /* REVERSE REVERB (kept + richer tail)
         - reverse segments and mix with smoothed tail
      */
      case "Reverse reverb":{
        const rev = new Float32Array(len);
        // reverse into rev, then apply a simple feedback tail (smoothing)
        for(let i=0;i<len;i++) rev[i] = src[len-1-i];
        // simple feedback lowpass tail
        const tail = new Float32Array(len);
        let acc = 0;
        const decay = 0.995 - chaosVal*0.15;
        for(let i=0;i<len;i++){
          acc = acc*decay + rev[i]*0.08*(1+chaosVal*0.5);
          tail[i] = acc;
        }
        for(let i=0;i<len;i++){
          const dry = src[i];
          const wet = tail[i];
          data[i] = dry*(1-mix) + wet*mix;
        }
      } break;

      /* EVOLVING BIT-CRUSH
         - downsample + bit-depth reduction that slowly evolves (modulated by chaos)
      */
      case "Evolving bit-crush":{
        const baseBits = Math.max(2, Math.floor(12 - mix*8));
        const L = len;
        // downsample rate changes slowly
        let phase = 0;
        const outc = new Float32Array(L);
        for(let i=0;i<L;i++){
          // evolving params
          if(i%256===0) phase = rnd();
          const bits = Math.max(2, Math.floor(baseBits - chaosVal*6*phase));
          const step = Math.pow(0.5, bits);
          const ds = Math.max(1, Math.floor(1 + Math.floor(1 + chaosVal*24*phase)));
          // sample-and-hold downsample
          const sampleIdx = Math.floor(i/ds)*ds;
          const s = src[sampleIdx] || 0;
          const crushed = Math.round(s/step)*step;
          outc[i] = crushed;
        }
        for(let i=0;i<L;i++){
          const fade = 1 - (i/L) * (loopToggle.checked?0:mix*0.8);
          data[i] = data[i]*(1-mix) + outc[i]*mix*fade;
        }
      } break;

      /* FLUTTER TREMOLO
         - random-ish LFO amplitude modulation, smoothed for musical flutter
      */
      case "Flutter tremolo":{
        const sr = buf.sampleRate;
        // base LFO rate depends on chaos
        const baseRate = 2 + chaosVal*12; // 2 - 14 Hz
        // use smoothed random LFO (pink-ish)
        let lfoPhase = 0;
        let lp = 0;
        for(let i=0;i<len;i++){
          const t = i/sr;
          // small deterministic + random mix
          const det = 0.5 + 0.5*Math.sin(2*Math.PI*baseRate*t + seed*0.0001);
          const rand = (rnd()-0.5)*chaosVal;
          // smoothed mod
          lp = lp*0.98 + (det*(1-chaosVal*0.7) + rand*chaosVal*0.7)*0.02;
          const mod = 1 + (lp - 0.5) * mix * 1.6;
          data[i] = src[i] * mod;
        }
      } break;

      default: break;
    }
  }
  return out;
}

/* Diffuse / preview / next / download flows */
async function diffuse(applyPreview=false){
  if(!originalBuffer) return alert("Upload a file first.");
  ensureCtx();
  currentSeed = Math.floor((Date.now() * (Math.random()+1)) % 2147483647);
  seedLabel.textContent = currentSeed;
  const algorithm = alg.value;
  const intensity = parseFloat(int.value);
  const chaosVal = parseFloat(chaos.value);
  const undefuseMode = undef.checked;
  processedBuffer = applyAlgorithm(originalBuffer, algorithm, intensity, chaosVal, currentSeed, undefuseMode);
  lastAlg = algorithm;
  if(applyPreview) playBuffer(processedBuffer);
}

function playBuffer(buf){
  if(!buf) return;
  ensureCtx();
  const wav = bufferToWavBlob(buf);
  const url = URL.createObjectURL(wav);
  player.src = url;
  player.loop = loopToggle.checked;
  player.play().catch(()=>ensureCtx().resume().then(()=>player.play()));
  drawWaveformFromBuffer(buf);
}

previewBtn.onclick = async ()=>{ if(!processedBuffer) await diffuse(true); else playBuffer(processedBuffer); }
diffBtn.onclick = async ()=>{ await diffuse(false); alert('Diffuse applied. Use Preview for live playback or Next for variations.'); }
nextBtn.onclick = async ()=>{ if(!originalBuffer) return alert("Upload a file first."); currentSeed = (currentSeed + Math.floor(Math.random()*9999)+1) % 2147483647; seedLabel.textContent = currentSeed; processedBuffer = applyAlgorithm(originalBuffer, alg.value, parseFloat(int.value), parseFloat(chaos.value), currentSeed, undef.checked); playBuffer(processedBuffer); }

downloadBtn.onclick = ()=>downloadCurrent();

function downloadCurrent(){
  const buf = processedBuffer || originalBuffer;
  if(!buf) return alert("Nothing to download yet.");
  let outBuf = buf;
  if(loopToggle.checked){
    outBuf = buf; // for brevity — leave as-is (could implement crossfade segment)
  }
  const blob = bufferToWavBlob(outBuf);
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = (document.querySelector('#alg').value.replace(/\s+/g,'_') || 'diffuse') + '.wav';
  document.body.appendChild(a); a.click(); a.remove();
}

/* WAV encoder */
function bufferToWavBlob(buffer){
  const numOfChan = buffer.numberOfChannels, sampleRate = buffer.sampleRate, format=1;
  const len = buffer.length * numOfChan * 2 + 44;
  const buf = new ArrayBuffer(len); const view = new DataView(buf);
  function writeString(view, offset, str){for(let i=0;i<str.length;i++)view.setUint8(offset+i,str.charCodeAt(i));}
  let offset=0;
  writeString(view, offset, 'RIFF'); offset+=4;
  view.setUint32(offset, 36 + buffer.length * numOfChan * 2, true); offset+=4;
  writeString(view, offset, 'WAVE'); offset+=4;
  writeString(view, offset, 'fmt '); offset+=4;
  view.setUint32(offset, 16, true); offset+=4;
  view.setUint16(offset, format, true); offset+=2;
  view.setUint16(offset, numOfChan, true); offset+=2;
  view.setUint32(offset, sampleRate, true); offset+=4;
  view.setUint32(offset, sampleRate * numOfChan * 2, true); offset+=4;
  view.setUint16(offset, numOfChan * 2, true); offset+=2;
  view.setUint16(offset, 16, true); offset+=2;
  writeString(view, offset, 'data'); offset+=4;
  view.setUint32(offset, buffer.length * numOfChan * 2, true); offset+=4;
  const interleaved = new Int16Array(buffer.length * numOfChan);
  for(let i=0, idx=0; i<buffer.length; i++){
    for(let ch=0; ch<numOfChan; ch++){
      const sample = Math.max(-1, Math.min(1, buffer.getChannelData(ch)[i] || 0));
      interleaved[idx++] = sample < 0 ? sample * 0x8000 : sample * 0x7fff;
    }
  }
  for(let i=0;i<interleaved.length;i++){ view.setInt16(offset, interleaved[i], true); offset+=2; }
  return new Blob([view], {type: 'audio/wav'});
}

/* live-update while adjusting sliders */
let liveTimeout;
function liveUpdate(){
  if(!originalBuffer) return;
  clearTimeout(liveTimeout);
  liveTimeout = setTimeout(()=>{
    processedBuffer = applyAlgorithm(originalBuffer, alg.value, parseFloat(int.value), parseFloat(chaos.value), currentSeed||Date.now(), undef.checked);
    playBuffer(processedBuffer);
  }, 120);
}

/* keyboard friendly: space toggles play */
document.addEventListener('keydown', e=>{ if(e.code==='Space'){ if(document.activeElement && ['INPUT','TEXTAREA','SELECT'].includes(document.activeElement.tagName)) return; e.preventDefault(); if(player.paused) player.play(); else player.pause(); } });

/* algorithm list interactions */
alg.onchange = ()=>{ refreshAlgList(); highlightAlg(); }
flipBtn.onclick = ()=>{
  for (let i = algList.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [algList[i], algList[j]] = [algList[j], algList[i]]; }
  const selected = alg.value;
  alg.innerHTML = '';
  algList.forEach(a=>{ const o = document.createElement('option'); o.textContent = a; alg.appendChild(o); });
  const idx = algList.indexOf(selected); if(idx>=0) alg.selectedIndex = idx;
  refreshAlgList();
};

/* waveform drawing (simple) */
const canvas = document.getElementById('wave'), ctx = canvas.getContext('2d');
function resizeCanvas(){ 
    canvas.width = canvas.clientWidth; 
    canvas.height = canvas.clientHeight; 
    drawEmptyWave(); 
}
function drawEmptyWave(){ 
    ctx.clearRect(0,0,canvas.width,canvas.height); 
    ctx.fillStyle = '#111'; 
    ctx.fillRect(0,0,canvas.width,canvas.height); 
    ctx.fillStyle = 'rgba(255,255,255,0.1)'; 
    ctx.fillRect(0,canvas.height/2,canvas.width,1); 
}
window.addEventListener('resize', ()=>{ resizeCanvas(); if(processedBuffer || originalBuffer) drawWaveformFromBuffer(processedBuffer || originalBuffer); });
resizeCanvas();

function drawWaveformFromBuffer(buf){
  if(!buf) return;
  const raw = buf.getChannelData(0);
  const w = canvas.width, h = canvas.height;
  const step = Math.ceil(raw.length / w);
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = '#111';
  ctx.fillRect(0,0,w,h);
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = 'var(--accent-color)';
  ctx.beginPath();
  const mid = h/2;
  for(let i=0; i<raw.length; i+=step){
    const x = Math.floor( (i/raw.length) * w );
    const v = raw[i];
    const y = mid + v * mid;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
}

/* initial highlight */
highlightAlg();

</script>
</body>
</html>
